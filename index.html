<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="飞龙在天的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="飞龙在天的博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="飞龙在天的博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>飞龙在天的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">飞龙在天的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/03/singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/03/singleton/" itemprop="url">单例模式漫谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-03T18:09:28+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单例模式，有“懒汉式”和“饿汉式”两种。</p>
<ul>
<li><p>懒汉式 - 单例类的实例在第一次被引用时候才被初始化。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>饿汉式 - 单例类的实例在加载的时候就被初始化。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在单线程程序中，上面两种形式基本可以满足要求了，但是在多线程环境下，单例类就有可能会失效，这个时候就要对其加锁了，来确保线程安全。对线程加锁用的synchronized关键字，这个关键字的用法主要也分为两种：</p>
<p>一种是加在方法名之前，二是声明同步块。下面是对懒汉式单例类加上线程同步的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式效率比较低，性能不是太好，不过也可以用，因为是对整个方法加上了线程同步，其实只要在new的时候考虑线程同步就行了，这种方法不推荐使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object syncLock = <span class="keyword">new</span> Object();  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">         </span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (syncLock) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>synchronized同步块括号中的锁定对象是采用的一个无关的Object类实例，而不是采用this，因为getInstance是一个静态方法，在它内部不能使用未静态的或者未实例的类对象，因此也可以用下面的方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处锁加在方法上的效率远低于同步代码块，因为同步方法锁只允许一个线程执行方法，其他线程阻塞，而代码块不同，允许并发访问方法，只是在代码块这里只允许一个线程执行，这种加锁方式肯定效率高。</p>
<p>在早期的JVM中，synchronized存在巨大的性能开销。因此，有人想出了一个“聪明”的技巧：双重检查锁定（Double-Checked Locking）。人们想通过双重检查锁定来降低同步的开销。下面是使用双重检查锁定来实现延迟初始化的示例代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">                instance = <span class="keyword">new</span> Instance(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">            &#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的Instance类变量是没有用volatile关键字修饰的，会导致这样一个问题：<br> <strong>在线程执行到第4行的时候，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</strong><br> 主要的原因是重排序。<strong>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</strong><br> 第7行的代码创建了一个对象，这一行代码可以分解成3个操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();　　<span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory);　<span class="comment">// 2：初始化对象</span></span><br><span class="line">instance = memory;　　<span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>
<p>根源在于代码中的2和3之间，可能会被重排序。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();　　<span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">instance = memory;　　<span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br><span class="line"><span class="comment">// 注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory);　<span class="comment">// 2：初始化对象</span></span><br></pre></td></tr></table></figure>
<p>这在单线程环境下是没有问题的，但在多线程环境下会出现问题：</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-12-03-115729.jpg" alt></p>
<p>B线程会看到一个还没有被初始化的对象。</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-12-03-115814.jpg" alt></p>
<p>A2和A3的重排序不影响线程A的最终结果，但会导致线程B在B1处判断出instance不为空，线程B接下来将访问instance引用的对象。此时，线程B将会访问到一个还未初始化的对象。<br> <strong>所以只需要做一点小的修改（把instance声明为volatile型），就可以实现线程安全的延迟初始化。</strong>因为被volatile关键字修饰的变量是被禁止重排序的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// 5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">                instance = <span class="keyword">new</span> Instance(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">            &#125; <span class="comment">// 8</span></span><br><span class="line">        &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/20/hbase-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/20/hbase-qa/" itemprop="url">Hbase常见问题QA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-20T11:45:37+08:00">
                2019-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>HMaster 的作用</strong></p>
<ul>
<li>为 region server 分配 region</li>
<li>负责 region server 的负载均衡</li>
<li>发现失效的 region server 并重新分配其上的 region</li>
<li>Gfs 上的垃圾文件回收</li>
<li>处理 schema 更新请求</li>
</ul>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/spark-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/spark-qa/" itemprop="url">Spark常见问题QA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T20:12:50+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/hive-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/hive-qa/" itemprop="url">Hive常见问题QA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T20:12:44+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/hadoop-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/19/hadoop-qa/" itemprop="url">Hadoop常见问题QA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T20:11:31+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>讲述 HDFS 上传文件和读文件的流程</strong></p>
<p>HDFS 上传流程，举例说明一个 256M 的文件上传过程</p>
<ol>
<li>由客户端 Client 向 NameNode 节点发出请求</li>
<li>NameNode 向 Client 返回可以存数据的 DataNode 列表，这里遵循机架感应原则(把副本分别放在不同的机架，甚至不同的数据中心)</li>
<li>客户端首先根据返回的信息先将文件分块(Hadoop2.X 版本每一个 block 为128M，而之前的版本为 64M)</li>
<li>通过 NameNode 返回的 DataNode 信息，将文件块以写入方式直接发送给DataNode，同时复制到其他两台机器(默认一份数据，有两个副本)</li>
<li>数据块传送完成以后，dataNode 向 Client 通信，同时向 NameNode 报告</li>
<li>依照上面(4)到(5)的原理将所有的数据块都上传，结束后向 NameNode 报告 表明已经传完所有的数据块。</li>
</ol>
<p>HDFS 上传流程如下图所示:</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-19-131551.png" alt="page4image18226704.png"> </p>
<p><strong>HDFS 在上传文件的时候，如果其中一个块突然损坏了怎么办?</strong></p>
<p>其中一个块坏了，只要有其它块存在，会自动检测还原。</p>
<p><strong>NameNode 的作用</strong></p>
<p>namenode 总体来说是管理和记录恢复功能。比如管理 datanode，保持心跳，如果超时则排除。对于上传文件都有镜像 images 和 edits,这些可以用来恢复。</p>
<p><strong>NameNode 在启动的时候会做哪些操作</strong></p>
<p>NameNode 启动的时候，会加载 fsimage</p>
<p>Fsimage 加载过程完成的操作主要是为了:</p>
<ol>
<li><p>从 fsimage 中读取该 HDFS 中保存的每一个目录和每一个文件</p>
</li>
<li><p>初始化每个目录和文件的元数据信息</p>
</li>
<li><p>根据目录和文件的路径，构造出整个 namespace 在内存中的镜像</p>
</li>
<li><p>如果是文件，则读取出该文件包含的所有 blockid，并插入到 BlocksMap 中。 整个加载流程如下图所示:</p>
<p> <img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-19-132951.png" alt="page6image17828496.png"> </p>
<p> 如上图所示，namenode 在加载 fsimage 过程其实非常简单，就是从 fsimage 中不停的顺序读取文件和目录的元数据信息，并在内存中构建整个 namespace，同时将每个文件对应的blockid 保存入 BlocksMap 中，此时 BlocksMap 中每个 block 对应的 datanodes 列表暂时为空。 当 fsimage 加载完毕后，整个 HDFS 的目录结构在内存中就已经初始化完毕，所缺的就是每 个文件对应的 block 对应的 datanode 列表信息。这些信息需要从 datanode 的 blockReport 中 获取，所以加载 fsimage 完毕后，namenode 进程进入 rpc 等待状态，等待所有的 datanodes发送 blockReports。</p>
</li>
</ol>
<p><strong>NameNode 的 HA</strong></p>
<p>NameNode 的 HA 一个备用，一个工作，且一个失败后，另一个被激活。他们通过 journal node 来实现共享数据。</p>
<p><strong>Hadoop 怎么分片</strong></p>
<p>HDFS 存储系统中，引入了文件系统的分块概念(block)，块是存储的最小单位，HDFS定义其大小为 64MB。与单磁盘文件系统相似，存储在 HDFS 上的文件均存储为多个块，不 同的是，如果某文件大小没有到达 64MB，该文件也不会占据整个块空间。在分布式的 HDFS集群上，Hadoop 系统 保证一个块存储在一个 datanode 上。</p>
<p>HDFS 的 namenode 只存储整个文件系统的元数据镜像，这个镜像由配置 dfs.name.dir 指定，datanode 则存有文件的 metainfo 和具体的分块，存储路径由 dfs.data.dir 指定。</p>
<p>分析完毕分块，下面讨论一下分片:<br>hadoop 的作业在提交过程中，需要把具体的输入进行分片。具体的分片细节由</p>
<p>InputSplitFormat 指定。分片的规则为 FileInputFormat.class 中的 getSplits()方法指定:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> splitSize = computeSplitSize(goalSize, minSize, blockSize);</span><br><span class="line">computeSplitSize:</span><br><span class="line">Math.max(minSize, Math.min(goalSize, blockSize));</span><br></pre></td></tr></table></figure>
<p>其中 goalSize 为“InputFile 大小”/“我们在配置文件中定义的 mapred.map.tasks”值，minsize 为 mapred.min.split.size，blockSize 为 64，所以，这个算式为取分片大小不大于 block， 并且不小于在 mapred.min.split.size 配置中定义的最小 Size。</p>
<p>当某个分块分成均等的若干分片时，会有最后一个分片大小小于定义的分片大小，则该 分片独立成为一个分片。</p>
<p><strong>如何减少 Hadoop Map 端到 Reduce 端的数据传输量</strong></p>
<p>减少传输量，可以让 map 处理完，让同台的 reduce 直接处理，理想情况下，没有数据传输。</p>
<p><strong>什么是Hadoop 的 Shuffle?</strong> </p>
<p>hadoop:map 端保存分片数据，通过网络收集到 reduce 端 Shuffle 产生的意义是什么? </p>
<p>完整地从 map task 端拉取数据到 reduce 端;在跨节点拉取数据时，尽可能地减少对带宽的不必要消耗;减少磁盘 IO 对 task 执行的影响</p>
<p>每个 map task 都有一个内存缓冲区，存储着 map 的输出结果当缓冲区快满的时候需要将缓冲区的数据以一个临时文件的方式存放到磁盘，当整个 map task 结束后再对磁盘中这个 map task 产生的所有临时文件做合并，生成最终的正式输 出文件，然后等待 reduce task 来拉数据 </p>
<p><strong>哪些场景才能使用 Combiner 呢?</strong></p>
<p>Combiner 的输出是 Reducer 的输入，Combiner 绝不能改变最终的计算结果。所以从我的想法来看，Combiner 只应该用于那种 Reduce 的输入 key/value 与输出 key/value 类型完全 一致，且不影响最终结果的场景。比如累加，最大值等。Combiner 的使用一定得慎重，如果用好，它对 job 执行效率有帮助，反之会影响 reduce 的最终结果。</p>
<p>combiner 最基本是实现本地 key 的聚合，对 map 输出的 key 排序，value 进行迭代。combiner 的目的是减少 map 网络流量。combiner 的对象是对于 map。combiner 具有和 reduce相似的功能。只不过 combiner 合并对象，是对于一个 map。reduce 合并对象，是对于多个map。</p>
<p><strong>如何实现 hadoop 的安全机制</strong> </p>
<ol>
<li><p>共享 hadoop 集群<br>  a: 管理人员把开发人员分成了若干个队列，每个队列有一定的资源，每个用户及用户组只能使用某个队列中指定资源</p>
<p> b: HDFS 上有各种数据，公用的，私有的，加密的。不用的用户可以访问不同的数据。 </p>
</li>
<li><p>HDFS 安全机制</p>
<p> client 获取 namenode 的初始访问认证( 使用 kerberos )后，会获取一个 delegation token， 这个 token 可以作为接下来访问 HDFS 或提交作业的认证。同样，读取 block 也是一样的</p>
</li>
<li><p>mapreduce 安全机制 </p>
<p>所有关于作业的提交或者作业运行状态的追踪均是采用带有 Kerberos 认证的 RPC 实现 的。授权用户提交作业时，JobTracker 会为之生成一个 delegation token，该 token 将被作为 job 的一部分存储到 HDFS 上并通过 RPC 分发给各个 TaskTracker，一旦 job 运行结束，该 token 失效。 </p>
</li>
<li><p>DistributedCache 是安全的</p>
<p> DistribuedCache 分别两种，一种是 shared，可以被所有作业共享，而 private 的只能被该用户的作业共享</p>
</li>
<li><p>RPC 安全机制 </p>
<p> 在 Hadoop RPC 中添加了权限认证授权机制。当用户调用 RPC 时，用户的 login name 会 通过 RPC 头部传递给 RPC，之后 RPC 使用 Simple Authentication and Security Layer(SASL)确 定一个权限协议(支持 Kerberos 和 DIGEST-MD5 两种)，完成 RPC 授权</p>
</li>
</ol>
<p><strong>hadoop 的调度策略的实现，你们使用的是那种策略，为什么。</strong></p>
<ol>
<li><p>默认情况下 hadoop 使用的 FIFO, 先进先出的调度策略。按照作业的优先级来处理。</p>
</li>
<li><p>计算能力调度器( Capacity Scheduler ) 支持多个队列，每个队列可配置一定的资源量，每个队列采用 FIFO, 为了防止同一个用户的作业独占资源，那么调度器会对同一个用户提交 的作业所占资源进行限定，首先按以下策略选择一个合适队列:计算每个队列中正在运行的任务数与其应该分得的计算资源之间的比值，选择一个该比值最小的队列;然后按以下 策略选择该队列中一个作业:按照作业优先级和提交时间顺序选择，同时考虑用户资源量限制和内存限制。</p>
</li>
<li><p>公平调度器( Fair Scheduler ) 支持多队列多用户，每个队列中的资源量可以配置，同一队列中的作业公平共享队列中所有资源。</p>
</li>
<li><p>异构集群的调度器 LATE</p>
</li>
<li><p>实时作业的调度器 Deadline Scheduler 和 Constraint-based Scheduler</p>
</li>
</ol>
<p><strong>数据倾斜怎么处理?</strong></p>
<p>数据倾斜有很多解决方案，本例子简要介绍一种实现方式，假设表 A 和表 B 连接，表A 数据倾斜，只有一个 key 倾斜，首先对 A 进行采样，统计出最倾斜的 key，将 A 表分隔为A1 只有倾斜 key， A2 不包含倾斜 key， 然后分别与 表 B 连接。最后将结果合并， union</p>
<ul>
<li><p>KYLIN-2895  Refine Query Cache：<a href="https://issues.apache.org/jira/browse/KYLIN-2895" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KYLIN-2895</a></p>
</li>
<li><ul>
<li>KYLIN-2899  Introduce segment level query cache：<a href="https://issues.apache.org/jira/browse/KYLIN-2899" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KYLIN-2899</a></li>
</ul>
</li>
<li><ul>
<li>KYLIN-2898  Introduce memcached as a distributed cache for queries：<a href="https://issues.apache.org/jira/browse/KYLIN-2898" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KYLIN-2898</a></li>
</ul>
</li>
<li><ul>
<li>KYLIN-2894  Change the query cache expiration strategy by signature checking：<a href="https://issues.apache.org/jira/browse/KYLIN-2894" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KYLIN-2894</a></li>
</ul>
</li>
<li><ul>
<li>KYLIN-2897  Improve the query execution for a set of duplicate queries in a short period：<a href="https://issues.apache.org/jira/browse/KYLIN-2897" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KYLIN-2897</a></li>
</ul>
</li>
<li><ul>
<li>KYLIN-2896  Refine query exception cache：<a href="https://issues.apache.org/jira/browse/KYLIN-2896" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/KYLIN-2896</a></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/15/jvm-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/15/jvm-qa/" itemprop="url">JVM常见问题QA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T21:53:12+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-17-java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" alt></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-17-091414.png" alt="image-20191117171414375"></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-17-091736.png" alt="image-20191117171735358"></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-17-091847.png" alt="image-20191117171846695"></p>
<p><strong>什么是类的加载</strong> ?</p>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中 的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p><strong>类的生命周期</strong></p>
<p>类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载，其中前三部是类的加载的过程,如下图:</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-17-092054.png" alt="page3image17869168.png"> </p>
<ul>
<li><p>加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象</p>
</li>
<li><p>连接，连接又包含三块内容:验证、准备、初始化。</p>
<p>  1)验证，文件格式、元数据、字节码、符号引用验证</p>
<p>  2)准备，为类的静态变量分配内存，并将其初始化为默认值</p>
<p>  3)解析，把类中的符号引用转换为直接引用</p>
</li>
<li><p>初始化，为类的静态变量赋予正确的初始值 </p>
</li>
<li>使用，new出对象程序中使用 </li>
<li>卸载，执行垃圾回收</li>
</ul>
<p><strong>类加载器</strong></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-17-093539.png" alt="page3image17885344.png"> </p>
<ul>
<li><p>启动类加载器: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库</p>
</li>
<li><p>扩展类加载器:Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。</p>
</li>
<li>应用程序类加载器:Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器</li>
</ul>
<p><strong>类加载机制</strong></p>
<ul>
<li>全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li>父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li>缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<p><strong>双亲委派模型</strong> </p>
<p>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。 自底向上的检查，自顶向下的加载</p>
<p>注意双亲委派模式的问题:无法识别应用程序类加载器中的类<br>解决方案:设置一个上下文加载器角色解决</p>
<p><strong>JVM内存结构</strong></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-093056.png" alt="page4image18274192.png"> </p>
<p>方法区和堆是所有线程共享的内存区域，而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。</p>
<ul>
<li><p>Java堆(Heap)，是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内 存。</p>
</li>
<li><p>方法区(Method Area)，方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 </p>
</li>
<li>程序计数器(Program Counter Register)，程序计数器(Program Counter Register)是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。</li>
<li>JVM栈(JVM Stacks)，与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>本地方法栈(Native Method Stacks)，本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</li>
</ul>
<p><strong>对象分配规则</strong></p>
<ul>
<li><p>对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 </p>
</li>
<li><p>大对象直接进入老年代(大对象是指需要大量连续内存空间的对象)。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝(新生代采用复制算法收集内存)。 </p>
</li>
<li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。</p>
</li>
<li><p>动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。</p>
</li>
<li>空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。</li>
</ul>
<p><strong>GC算法 垃圾回收</strong></p>
<ul>
<li><p>对象存活判断</p>
<p>  判断对象是否存活一般有两种方式:</p>
<p>  引用计数: 每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。 </p>
<p>  可达性分析(Reachability Analysis): 从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。</p>
</li>
<li><p>GC算法<br>  GC最基础的算法有三种:标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。</p>
<ul>
<li><p>标记 -清除算法，“标记-清除”(Mark-Sweep)算法，如它的名字一样，算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。</p>
</li>
<li><p>复制算法，“复制”(Copying)的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的 内存空间一次清理掉。</p>
</li>
<li><p>标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
</li>
<li>分代收集算法，“分代收集”(Generational Collection)算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</li>
</ul>
</li>
<li><p>垃圾回收器</p>
<ul>
<li><p>Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。</p>
</li>
<li><p>ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。</p>
</li>
<li>Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。</li>
<li>Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法</li>
<li>CMS收集器，CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。</li>
<li>G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征</li>
</ul>
</li>
</ul>
<p><strong>GC分析 命令调优</strong> </p>
<ul>
<li><p>GC日志分析</p>
<p>  摘录GC日志一部分(前部分为年轻代gc回收;后部分为full gc回收):</p>
<p>  <img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-071817.png" alt="image-20191118151816763"></p>
<p>  通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化;ParOldGen表示gc回收前后老年代的内存变化;PSPermGen表示gc回收前后永 久区的内存变化。young gc 主要是针对年轻代进行内存回收比较频繁，耗时短;full gc 会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数<br>  young gc 日志:</p>
<p>  <img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-074702.jpg" alt="page5image18107232.jpg"> </p>
<p>  Full GC日志:</p>
<p>  <img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-074738.jpg" alt="page5image18105152.jpg"></p>
</li>
</ul>
<ul>
<li>调优命令<br>  Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo<ul>
<li>jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</li>
<li>jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</li>
<li>jmap，JVM Memory Map命令用于生成heap dump文件</li>
<li>jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看jstack，用于生成java虚拟机当前时刻的线程快照。</li>
<li>jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</li>
</ul>
</li>
</ul>
<ul>
<li><p>Jvm调优-命令篇调优工具</p>
<p>  常用调优工具分为两类,jdk自带监控工具:jconsole和jvisualvm，第三方有:MAT(Memory Analyzer Tool)、GChisto。</p>
<ul>
<li>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</li>
<li>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照;监控内存变化、GC变化等。</li>
<li>MAT，Memory Analyzer Tool，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</li>
<li>GChisto，一款专业分析gc日志的工具</li>
</ul>
</li>
</ul>
<p><strong>你知道哪些JVM性能调优</strong></p>
<ul>
<li><p>设定堆最小内存大小-Xms </p>
</li>
<li><p>-Xmx:堆内存最大限制。 </p>
</li>
<li><p>设定新生代大小。</p>
<ul>
<li>新生代不宜太小，否则会有大量对象涌入老年代</li>
<li>-XX:NewSize:新生代大小</li>
<li>-XX:NewRatio 新生代和老生代占比</li>
<li>-XX:SurvivorRatio:Eden区与每一个Survivor区的比值</li>
</ul>
</li>
<li><p>设定垃圾回收器</p>
<p>  年轻代用 -XX:+UseParNewGC (串行) 年老代用-XX:+UseConcMarkSweepGC (CMS)</p>
</li>
<li><p>设定锁的使用</p>
<p>  多线程下关闭偏向锁，比较浪费资源</p>
</li>
</ul>
<p><strong>g1 和 cms 区别</strong></p>
<p>吞吐量优先和响应优先的垃圾收集器选择</p>
<p>CMS是一种以最短停顿时间为目标的收集器 响应优先选择CMS,吞吐量高选择G1</p>
<p><strong>当出现了内存溢出，怎么排错</strong><br>用jmap看内存情况，然后用 jstack主要用来查看某个Java进程内的线程堆栈信息</p>
<p>然后看报错的信息信息定位发生OOM的位置:堆，java虚拟机栈，永久区，直接内存 然后根据具体的问题提出具体的解决方案</p>
<p><strong>JVM的一些参数设定</strong></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-092720.png" alt="page4image18102912.png"> </p>
<p><strong>JVM调优</strong></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-092817.png" alt="page4image18097296.png"> </p>
<p><strong>偏向锁</strong></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-11-18-092857.jpg" alt="page4image18094384.jpg"> </p>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/15/java-qa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/15/java-qa/" itemprop="url">Java常见问题QA</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-15T21:53:00+08:00">
                2019-11-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index">
                    <span itemprop="name">JAVA</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Java的HashMap是如何工作的?</strong></p>
<p>HashMap是一个针对键值的数据结构，每个键都会有相应的值。HashMap 基于 hashing 原理，我们通过 put ()和 get ()方法储存和获取对象。当我们将键值对传递给 put ()方法时，它调用键对象的 hashCode ()方法来计算 hashcode，让后找到 bucket 位置来储存 值对象。当获取对象时，通过键对象的 equals ()方法找到正确的键值对，然后返回值对象。HashMap 使用 LinkedList 来解决碰撞问题，当发生碰撞了，对象将会储存在 LinkedList 的下一个节 点中。 HashMap 在每个 LinkedList 节点中储存键值对对象。</p>
<p><strong>什么是快速失败的故障安全迭代器?</strong></p>
<p>快速失败的Java迭代器可能会引发ConcurrentModifcationException在底层集合迭代过程中被修改。故障安全作为发生在实例中的一个副本迭代是不会抛出任何异常的。快速失败的故障安全范例定义了当遭遇故障时系统是如何反应的。例如，用于失败的快速迭代器ArrayList和用于故障安全的迭代器ConcurrentHashMap。</p>
<p><strong>Java BlockingQueue是什么?</strong></p>
<p>Java BlockingQueue是一个并发集合util包的一部分。BlockingQueue队列是一种支持操作，它等待元素变得可用时来检索，同样等待空间可用时来存储元素。</p>
<p><strong>什么时候使用ConcurrentHashMap?</strong></p>
<p>ConcurrentHashMap被作为故障安全迭代器的一个实例，它允许完整的并发检索和更新。当有大量的并发更新时，ConcurrentHashMap此时可以被使用。这非常类似于Hashtable，但ConcurrentHashMap不锁定整个表来提供并发，所以从这点上ConcurrentHashMap的性能似乎更好一些。所以当有大量更新时ConcurrentHashMap应该被使用。</p>
<p><strong>哪一个List实现了最快插入?</strong></p>
<p>LinkedList和ArrayList是两个不同变量列表的实现。ArrayList的优势在于动态的增长数组，非常适合初始时总长度未知的情况下使用。LinkedList的优势在于在中间位置插入和删除操作，速度是最快的。LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈(stack)，队列(queue)或双向队列(deque)。<br>ArrayList实现了可变大小的数组。它允许所有元素，包括null。 每个ArrayList实例都有一个容量(Capacity)，即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p>
<p><strong>Iterator和ListIterator的区别是什么?</strong></p>
<ul>
<li><p>ListIterator有add()方法，可以向List中添加对象，而Iterator不能。</p>
</li>
<li><p>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向(顺序向前)遍历。Iterator就不可以。</p>
</li>
<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。</li>
<li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</li>
</ul>
<p><strong>什么是CopyOnWriteArrayList，它与ArrayList有何不同?</strong></p>
<p>CopyOnWriteArrayList是ArrayList的一个线程安全的变体，其中所有可变操作(add、set等等)都是通过对底层数组进行一次新的复制来实现的。相比较于ArrayList它的写操作要慢一些，因为它需要实例的快照。</p>
<p>CopyOnWriteArrayList中写操作需要大面积复制数组，所以性能肯定很差，但是读操作因为操作的对象和写操作不是同一个对象，读之间也不需要加锁，读和写之间的同步处理只是在写完后 通过一个简单的”=”将引用指向新的数组对象上来，这个几乎不需要时间，这样读操作就很快很安全，适合在多线程里使用，绝对不会发生ConcurrentModificationException ，因此CopyOnWriteArrayList适合使用在读操作远远大于写操作的场景里，比如缓存。</p>
<p><strong>迭代器和枚举之间的区别</strong></p>
<ul>
<li><p>Iterator允许移除从底层集合的元素。</p>
</li>
<li><p>Iterator的方法名是标准化的。</p>
</li>
</ul>
<p>Aaa</p>
<p><strong>Hashmap如何同步?</strong></p>
<p>当我们需要一个同步的HashMap时，有两种选择:</p>
<ul>
<li><p>使用Collections.synchronizedMap(..)来同步HashMap。</p>
</li>
<li><p>使用ConcurrentHashMap</p>
</li>
</ul>
<p><strong>IdentityHashMap和HashMap的区别</strong></p>
<p>IdentityHashMap是Map接口的实现。不同于HashMap的，这里采用参考平等。</p>
<ul>
<li><p>在HashMap中如果两个元素是相等的，则key1.equals(key2)</p>
</li>
<li><p>在IdentityHashMap中如果两个元素是相等的，则key1 == key2</p>
</li>
</ul>
<p><strong>进程与线程区别以及线程相关概念</strong></p>
<p>进程就是运行中的程序，每个进程占用独自的内存空间</p>
<p>线程属于进程，一个进程可以有一个或多个线程，这些线程共享这个进程的内存或系统资源，线程的切换比进程切换的负担要小。一个Java应用总是从main()方法开始运行，mian()方法运行在一个线程内，它被称为主线程。多线程的最终目的是尽可能的利用cpu资源，不让其闲置。</p>
<p><strong>两种创建线程的方式</strong></p>
<p>(1) 继承Thread类，实现其run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2) 实现Runnale接口，实现run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Thread源代码分析特点</strong></p>
<p>(1)Thread类实现了Runnale接口，实现了其run方法</p>
<p>(2)当生成一个线程对象的时候，如果没有为其设定名字，线程对象将使用如下形式:Thread-number(该number是自动增加的并共享于该类其它对象)</p>
<p>(3)两种方法均需要执行start方法分配必须的系统资源，调度线程运行并执行run</p>
<p>(4)在具体应用中，采用那种方式看情况而定，但当一个线程继承了另外一个类时，只能实现Runnable接口</p>
<p><strong>线程的生命周期</strong></p>
<p>概念:一个线程从创建到消亡的过程。</p>
<p>状态:</p>
<p>(1)创建状态:new—start之间称为创建状态，创建状态的线程是一个空线程系统不为其非配资源。</p>
<p>(2)可运行状态:start–run可运行但并不是一定在运行，只是拥有了运行的条件。</p>
<p>(3)不可运行状态:当调用了sleep方法或者wait方法。在指定时间后恢复或调用notify相关方法恢复。</p>
<p>(4)退出状态:调用了stop方法或者自然消亡。线程的停止:线程的消亡不能通过一个stop()命令，而是让run方法自然结束。可以在while循环里面条件判断break或者return。</p>
<p><strong>线程的优先级</strong></p>
<p>1.线程的优先级及其设置</p>
<p>目的:设置优先级是为了在多线程环境中便于系统对线程的调度，优先级高的线程将优先执行。</p>
<p>原则:</p>
<p>—-线程创建时，子继承父的优先级</p>
<p>—-setPriority()方法改变优先级</p>
<p>—-优先级数由低到高是1——10的正整数，默认为5.(动态)</p>
<p>2.线程的调度策略</p>
<p>线程调度器选择优先级最高的线程运行，但是，如果发生以下情况，就会终止线程的运行:</p>
<p>(1)线程体中调用了yield方法让出了对cpu的占用权利</p>
<p>(2)线程体中调用了sleep方法使线程进入睡眠状态</p>
<p>(3)线程由于IO操作受到阻塞</p>
<p>(4)另外一个更高优先级线程出现</p>
<p>(5)在支持时间片的系统中，该线程的时间片用完。</p>
<p><strong>关于成员变量和局部变量</strong></p>
<p>如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作的时候，他们对该成员变量是彼此影响的，也就是说一个线程对成员变量的改变会影响到另外一个线程</p>
<p>如果一个变量是局部变量，那么 每个线程都会有一个该局部变量的拷贝，一个线程对该局部变量的改变不会影响到其它的线程。</p>
<p><strong>多线程同步问题(重点)</strong></p>
<p>为什么要引入同步机制?在多线程环境中，可能会有两个甚至更多的线程试图同时访问一个有限的资源。必须对这种潜在资源冲突进行预防。 解决方法:在线程使用一个资源时为其加锁即可。访问资源的第一个线程为其加上锁以后，其它线程便不能在使用那个资源，除非被解决。</p>
<p>Synchronized: </p>
<p>当Synchronized关键字修饰一个方法的时候，该方法叫做同步方法。java中的每个对象都有一个锁(lock)或者叫做监视器(monitor),当访问某个对象的synchronized方法的时候，表示将对象上锁，此时其它任何线程 都无法再去访问synchronized方法了，直到之前的那个线程执行方法完毕后(或者是抛出了异常)，那么将该对象的锁释放掉，其他线程才有可能再去访问该synchronized方法。</p>
<p>注意1:</p>
<p>如果一个对象有多个synchronized方法，某一个时刻某个线程已经进入到了某个synchronized方法，那么在该方法没有执行完毕前，其它线程是无法访问该对象的任何synchronzed方法的。</p>
<p>注意2: </p>
<p>如果某个Synchronized方法是static的，那么当线程访问该方法时，它锁的并不是Synchronized方法所在的对象，而是Synchronized方法所在的对象所对象的Class对象，因为java中无论一个类有多少个对象，这些对象会 对应唯一一个class对象，因此当线程分别访问同一个类的两个对象的两个static Synchronized方法的时候，他们执行的顺序也是顺序的，也就是说一个线程先去执行方法，执行完毕后另一个线程才开始执行。</p>
<p>写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">	    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized方法和块比较</strong></p>
<p>synchronized方法是一种粗粒度的并发控制，某一个时刻，只能有一个线程执行该synchronized方法，而synchronized块则是一种细粒度的并发控制，只会将块中的代码同步，位于方法内。synchronized块外之外的代码是可以被多个线程同时访问到的。</p>
<p><strong>wait、notify、sleep方法</strong></p>
<p>wait与notify方法都是定义在Object类中，而且是final的，因此会被所有的java类所继承并且无法重写，这两个方法要求在调用时线程应该已经获得了对象的锁，因此对这两个方法的调用需要方法synchronized方法或者块中，当线程执行了wait方法时，它会释放掉对象的锁。</p>
<p>另外一个会导致线程暂停的方法就是Thread类的sleep方法，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。</p>
<p><strong>Thread类中的start()和 run()方法有什么区别?</strong></p>
<p>start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时 候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<p><strong>Java中Runnable和Callable有什么不同?</strong></p>
<p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这 些功能。Callable可以返回装载有计算结果的Future对象。</p>
<p><strong>Java中CyclicBarrier和 CountDownLatch有什么不同?</strong></p>
<p>CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。</p>
<p><strong>Java中的volatile 变量是什么?</strong></p>
<p>volatile是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile变量可以保证下一个读取操作会在前一个写操作之后发生。</p>
<p><strong>什么是线程安全?Vector是一个线程安全类吗?</strong></p>
<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。一个线程 安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。</p>
<p>Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是 线程安全的。</p>
<p><strong>Java中什么是竞态条件? 举个例子说明。</strong></p>
<p>竞态条件会导致程序在并发情况下出现一些bugs。多线程对一些资源的竞争的时候就会产生竞态条件，如果首先要执行的程序竞争失败排到后面执行了，那么整个程序就会出现一些不确定的bugs。这种bugs很难发现 而且会重复出现，因为线程间的随机竞争。</p>
<p><strong>Java中如何停止一个线程?</strong></p>
<p>Java提供了很丰富的API但没有为停止线程提供API。JDK 1.0本来有一些像stop(), suspend() 和 resume()的控制方法但是由于潜在的死锁威胁因此在后续的JDK版本中他们被弃用了，之后Java API的设计者就没有提供 一个兼容且线程安全的方法来停止一个线程。当run() 或者 call() 方法执行完的时候线程会自动结束,如果要手动结束一个线程，你可以用volatile 布尔变量来退出run()方法的循环或者是取消任务来中断线程。或者使用Interrupt方法。</p>
<p><strong>一个线程运行时发生异常会怎样?</strong></p>
<p>如果异常没有被捕获该线程将会停止执行。Thread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p>
<p><strong>如何在两个线程间共享数据?</strong></p>
<p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。</p>
<ul>
<li><p>使用Map实现线程范围内数据的共享</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadScopeSharaData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Thread, Integer&gt; threadData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" put random data:"</span> + data);</span><br><span class="line">                    threadData.put(Thread.currentThread(), data);</span><br><span class="line">                    <span class="keyword">new</span> A().get();</span><br><span class="line">                    <span class="keyword">new</span> B().get();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadData.get(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A from "</span> + Thread.currentThread().getName() + <span class="string">" get data:"</span> + data);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadData.get(Thread.currentThread());</span><br><span class="line">            System.out.println(<span class="string">"B from "</span> + Thread.currentThread().getName() + <span class="string">" get data:"</span> + data);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadLocal实现线程范围内数据的共享</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> data = <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" put random data:"</span> + data);</span><br><span class="line">                    threadLocal.set(data);</span><br><span class="line">                    <span class="keyword">new</span> A().get();</span><br><span class="line">                    <span class="keyword">new</span> B().get();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadLocal.get();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"A from "</span> + Thread.currentThread().getName() + <span class="string">" get data:"</span> + data);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> data = threadLocal.get();</span><br><span class="line">            System.out.println(<span class="string">"B from "</span> + Thread.currentThread().getName() + <span class="string">" get data:"</span> + data);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Java中notify 和 notifyAll有什么区别?</strong></p>
<p>notify()方法不能唤醒某个具体的线程，所以只有一个线程在等待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
<p><strong>为什么wait, notify 和 notifyAll这些方法不在thread类里面?</strong></p>
<p>一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正 在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<p><strong>什么是ThreadLocal变量?ThreadLocal是Java里一种特殊的变量。</strong></p>
<p>每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先， 通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。</p>
<p><strong>什么是FutureTask?</strong></p>
<p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<p><strong>Java中interrupted和 isInterruptedd方法的区别?</strong></p>
<p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方 法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<p><strong>为什么wait和notify方法要在同步块中调用?</strong><br>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<p><strong>为什么你应该在循环中检查等待条件?</strong></p>
<p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因。</p>
<p><strong>Java中的同步集合与并发集合有什么区别?</strong></p>
<p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍 了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。</p>
<p><strong>Java中堆和栈有什么不同?</strong></p>
<p>每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的。 而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<p><strong>什么是线程池? 为什么要使用它?</strong></p>
<p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务;数目固定的线程池或者是缓存线程池(一个适合很多生存期短的任务的程序的可 扩展线程池)。</p>
<p><strong>如何写代码来解决生产者消费者问题?</strong></p>
<p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比较低级的办法是用wait和notify来解决这个问题，比较赞 的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by lewis on 2017/4/11.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产者消费者模型</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerProblem</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始容量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * full 产品容量</span></span><br><span class="line"><span class="comment">     * empty 空余容量</span></span><br><span class="line"><span class="comment">     * mutex 读写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore full,empty,mutex;</span><br><span class="line">    <span class="comment">//记录当前的产品数量</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * full 初始化0个产品</span></span><br><span class="line"><span class="comment">          * empty 初始化有N个空余位置放置产品</span></span><br><span class="line"><span class="comment">          * mutex 初始化每次最多只有一个线程可以读写</span></span><br><span class="line"><span class="comment">          * */</span></span><br><span class="line">         full = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">         empty = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line">         mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">         <span class="comment">//生产线线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer()).start();</span><br><span class="line">        <span class="comment">//消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    empty.acquire();<span class="comment">//等待空位</span></span><br><span class="line">                    mutex.acquire();<span class="comment">//等待读写锁</span></span><br><span class="line">                    count++;</span><br><span class="line">                    out.println(<span class="string">"生产者生产了一个，还剩："</span>+count);</span><br><span class="line">                    mutex.release();<span class="comment">//释放读写锁</span></span><br><span class="line">                    full.release();<span class="comment">//放置产品</span></span><br><span class="line">                    <span class="comment">//随机休息一段时间，让生产者线程有机会抢占读写锁</span></span><br><span class="line">                    Thread.sleep(((<span class="keyword">int</span>)Math.random())%<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    full.acquire();<span class="comment">//等待产品</span></span><br><span class="line">                    mutex.acquire();<span class="comment">//等待读写锁</span></span><br><span class="line">                    count--;</span><br><span class="line">                    out.println(<span class="string">"消费者消费了一个，还剩："</span>+count);</span><br><span class="line">                    mutex.release();<span class="comment">//释放读写锁</span></span><br><span class="line">                    empty.release();<span class="comment">//释放空位</span></span><br><span class="line">                    <span class="comment">//随机休息一段时间，让消费者线程有机会抢占读写锁</span></span><br><span class="line">                    Thread.sleep(((<span class="keyword">int</span>)Math.random())%<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何避免死锁?</strong></p>
<p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必 须满足以下四个条件:</p>
<ul>
<li>互斥条件: 一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。 </li>
<li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序(升序或降序)做操作来避免死锁。</p>
<p><strong>Java中活锁和死锁有什么区别?</strong></p>
<p>活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。</p>
<p><strong>怎么检测一个线程是否拥有锁?</strong></p>
<p>在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<p><strong>如何在Java中获取线程堆栈?</strong></p>
<p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<p><strong>JVM中哪个参数是用来控制线程的栈堆栈小的</strong></p>
<p>-Xss参数用来控制线程的堆栈大小。</p>
<p><strong>Java中synchronized和 ReentrantLock有什么不同?</strong></p>
<p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5通过Lock接口提供了更复杂的控制来解决这些问题。ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<p><strong>有三个线程T1，T2，T3，怎么确保它们按顺序执行?</strong></p>
<p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<p><strong>Thread类中的yield方法有什么作用?</strong></p>
<p>yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<p><strong>Java中ConcurrentHashMap的并发度是什么?</strong></p>
<p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p>
<p><strong>Java中Semaphore是什么?</strong></p>
<p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<p><strong>如果你提交任务时，线程池队列已满。会发生什么?</strong></p>
<p>事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常</p>
<p><strong>Java线程池中submit() 和 execute()方法有什么区别?</strong></p>
<p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<p><strong>什么是阻塞式方法?</strong></p>
<p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还 有异步和非阻塞式方法在任务完成前就返回。</p>
<p><strong>Java中invokeAndWait 和 invokeLater有什么区别?</strong></p>
<p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进度更新了，进度条也要做出相应改变。如果进度被多 个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而invokeLater()方法是异步调用更新组件的。</p>
<p><strong>如何在Java中创建Immutable对象?</strong></p>
<p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤:通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。</p>
<p><strong>Java中的ReadWriteLock是什么?</strong></p>
<p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下 一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。</p>
<p><strong>多线程中的忙循环是什么?</strong></p>
<p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个 等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<p><strong>volatile 变量和 atomic 变量有什么不同?</strong></p>
<p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<p><strong>如果同步块内的线程抛出异常会发生什么?</strong></p>
<p>无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在finally block里释放锁实现。</p>
<p><strong>写出3条你遵循的多线程最佳实践</strong></p>
<ul>
<li><p>给你的线程起个有意义的名字。</p>
<p>  这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个 最佳实践。</p>
</li>
<li><p>避免锁定和缩小同步的范围 </p>
<p>  锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</p>
</li>
<li><p>多用同步类少用wait 和 notify<br>  首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。 </p>
</li>
<li><p>多用并发集合少用同步集合</p>
<p>  这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</p>
</li>
</ul>
<p><strong>如何强制启动一个线程?</strong></p>
<p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API</p>
<p><strong>Java中的fork join框架是什么?</strong></p>
<p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/09/learn-git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/learn-git/" itemprop="url">使用git进行项目版本管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T17:29:45+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文以Apache Kylin为例，介绍使用git进行项目分支管理，以及常见开发中的问题及解决方法。</p>
<h4 id="常见的分支类型"><a href="#常见的分支类型" class="headerlink" title="常见的分支类型"></a>常见的分支类型</h4><p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-083425.png" alt="2019-07-09-103846"></p>
<p>上图为截取的最近Apache Kylin项目的分支图，目前主要有以下几种分支类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">master分支</th>
<th style="text-align:center">维护分支</th>
<th style="text-align:center">feature分支</th>
<th style="text-align:center">release分支</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">作用</td>
<td style="text-align:center">最新的代码，随时会被更新</td>
<td style="text-align:center">维护版本的代码，理论上只接受改动较小的enhancement和bug fix</td>
<td style="text-align:center">为开发一些大改动的功能单拉的分支</td>
<td style="text-align:center">用作版本发布的分支</td>
</tr>
<tr>
<td style="text-align:center">例子</td>
<td style="text-align:center">master</td>
<td style="text-align:center">2.6.x</td>
<td style="text-align:center">engine-flink, kylin-on-druid</td>
<td style="text-align:center">v2.6.3-release, v-3.0.0-alpha-release</td>
</tr>
<tr>
<td style="text-align:center">生命周期</td>
<td style="text-align:center">从项目诞生到删除</td>
<td style="text-align:center">从一个稳定的维护系列版本产生到该系列版本停止维护</td>
<td style="text-align:center">从feature诞生到合并进入主分支</td>
<td style="text-align:center">从准备发布到发布正式annunce</td>
</tr>
</tbody>
</table>
<p>每一个版本release后，都会打上对应的tag，目前有kylin-2.6.3, kylin-3.0.0-alpha等</p>
<h4 id="常用的git命令"><a href="#常用的git命令" class="headerlink" title="常用的git命令"></a>常用的git命令</h4><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><ul>
<li><p>查看</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git status #显示有变更的文件</span><br><span class="line"></span><br><span class="line">git log #显示当前分支的版本历史</span><br><span class="line"></span><br><span class="line">git log --stat #显示commit历史，以及每次commit发生变更的文件</span><br><span class="line"></span><br><span class="line">git blame [file] #显示指定文件是什么人在什么时间修改过</span><br><span class="line"> </span><br><span class="line">git diff #显示暂存区和工作区的差异</span><br><span class="line"></span><br><span class="line">git diff HEAD #显示工作区与当前分支最新commit之间的差异</span><br><span class="line"></span><br><span class="line">git show [commit] #显示某次提交的元数据和内容变化</span><br><span class="line"></span><br><span class="line">git show [commit]:[filename] #显示某次提交时，某个文件的内容</span><br><span class="line"></span><br><span class="line">git reflog #显示当前分支的最近几次提交</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加/删除文件</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git add [file1] #添加指定文件到暂存区</span><br><span class="line"></span><br><span class="line">git add [dir] #添加指定目录到暂存区，包括子目录</span><br><span class="line"></span><br><span class="line">git add . #添加当前目录的所有文件到暂存区</span><br><span class="line"></span><br><span class="line">git rm [file1] #删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line"></span><br><span class="line">git rm --cached #[file] 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line"></span><br><span class="line">git mv &lt;file_original&gt; &lt;file_renamed&gt; #改名文件，并且将这个改名放入暂存区</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码提交</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git commit -m [message] #提交暂存区到仓库区</span><br><span class="line"></span><br><span class="line">git commit [file1] -m [message] #提交暂存区的指定文件到仓库区</span><br><span class="line"></span><br><span class="line">git commit -a #提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line"></span><br><span class="line">git commit -v #提交时显示所有diff信息</span><br><span class="line"></span><br><span class="line">git commit --amend -m [message] #使用一次新的commit，替代上一次提交. 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line"></span><br><span class="line">git commit --amend [file1] #重做上一次commit，并包括指定文件的新变化</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程仓库</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">git clone [远程仓库地址] #从远程仓库克隆</span><br><span class="line"></span><br><span class="line">git fetch &lt;远程主机名&gt; &lt;分支名&gt; #更新远程仓库的所有变动，如git fetch origin master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要更新所有分支，命令可以简写为 git fetch</span></span><br><span class="line"></span><br><span class="line">git remote -v #显示所有远程仓库</span><br><span class="line"></span><br><span class="line">git remote show [remote] #显示某个远程仓库的信息</span><br><span class="line"></span><br><span class="line">git remote add [shortname] [url] #增加一个新的远程仓库，并命名</span><br><span class="line"></span><br><span class="line">git pull [remote] [branch] # 取回远程仓库的变化，并与本地分支合并</span><br><span class="line"></span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; #将本地分支的更新，推送到远程主机</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果省略远程分支名，则表示将本地分支推送与之存在<span class="string">"追踪关系"</span>的远程分支 git push origin master </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前分支与远程分支之间存在追踪关系, 则本地分支和远程分支都可以省略 git push origin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前分支只有一个追踪分支，那么主机名都可以省略 git push</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ！！！！慎用，有被杀了祭天的风险 ！！！！</span></span><br><span class="line">git push --force origin # 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项</span><br><span class="line"><span class="meta">#</span><span class="bash"> ！！！！慎用，有被杀了祭天的风险 ！！！！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标签管理</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;name&gt; #在当前分支打标签</span><br><span class="line"></span><br><span class="line">git tag #查看所有标签</span><br><span class="line"></span><br><span class="line">git show &lt;tagname&gt; #查看标签信息</span><br><span class="line"></span><br><span class="line">git tag -a &lt;tagname&gt; -m "" #可以指定标签信息</span><br><span class="line"></span><br><span class="line">git push origin &lt;tagname&gt; #推送一个本地标签</span><br><span class="line"></span><br><span class="line">git push origin --tags #推送全部未推送过的本地标签</span><br><span class="line"></span><br><span class="line">git tag -d &lt;tagname&gt; #删除一个本地标签</span><br><span class="line"></span><br><span class="line">git push origin:refs/tags/&lt;tagname&gt; #删除一个远程标签</span><br><span class="line"></span><br><span class="line">git checkout &lt;tagname&gt; #checkout到一个指定tag下对应的代码</span><br></pre></td></tr></table></figure>
</li>
<li><p>分支管理</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev #创建并切换到dev分支</span><br><span class="line"></span><br><span class="line">git branch dev #创建分支</span><br><span class="line"></span><br><span class="line">git checkout dev #切换分支</span><br><span class="line"></span><br><span class="line">git branch #查看当前分支</span><br><span class="line"></span><br><span class="line">git merge dev #当前分支与dev分支合并</span><br><span class="line"></span><br><span class="line">git branch -d dev #删除dev分支</span><br><span class="line"></span><br><span class="line"> git push --set-upstream &lt;remote&gt; &lt;branch_name&gt; #将当前分支提交到远端</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">git checkout [file] #恢复暂存区的指定文件到工作区</span><br><span class="line"></span><br><span class="line">git checkout [commit] [file] #恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line"></span><br><span class="line">git checkout . #恢复暂存区的所有文件到工作区</span><br><span class="line"></span><br><span class="line">git reset [file] #重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line"></span><br><span class="line">git reset --hard #重置暂存区与工作区，与上一次commit保持一致 </span><br><span class="line"></span><br><span class="line">git reset [commit] #重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line"></span><br><span class="line">git reset --hard [commit] #重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">git reset --keep [commit] #重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line"></span><br><span class="line">git revert [commit] #新建一个commit，用来撤销指定commit  后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line"></span><br><span class="line">git stash #暂时将未提交的变化移除</span><br><span class="line"></span><br><span class="line">git stash pop #将在缓冲区的变动移入</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="理解HEAD"><a href="#理解HEAD" class="headerlink" title="理解HEAD"></a>理解HEAD</h5><p>Git 中的 HEAD 可以理解为指针，指向当前仓库所处的分支。一般在有 git 管理的目录下打开 git 终端都能在当前路径的尾巴上，看到所处的分支名。</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-083616.jpg" alt="2019-07-10-060207"></p>
<p>当使用 <code>git checkout &lt; branch_name&gt;</code> 切换分支时，HEAD 会移动到指定分支。</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-083701.jpg" alt="2019-07-10-060918"></p>
<p>但是如果使用的是 <code>git checkout &lt;commit id&gt;</code>，即切换到指定的某一次提交，HEAD 就会处于 detached 状态（游离状态）。在这个基础上的提交会新开一个匿名分支。</p>
<h4 id="常见案例"><a href="#常见案例" class="headerlink" title="常见案例"></a>常见案例</h4><h5 id="如何提交一个Kylin的Pull-Request"><a href="#如何提交一个Kylin的Pull-Request" class="headerlink" title="如何提交一个Kylin的Pull Request"></a>如何提交一个Kylin的Pull Request</h5><ul>
<li><p>Fork Apache Kylin项目，则会生成个人的Kylin项目，如<a href="https://github.com/nichunen/kylin.git" target="_blank" rel="noopener">https://github.com/nichunen/kylin.git</a></p>
</li>
<li><p>Clone个人fork的项目到本地 </p>
<p>  <code>git clone https://github.com/nichunen/kylin.git</code></p>
</li>
<li><p>基于master分支或feature分支新建一个分支，一般为Jira issue号</p>
<p>  <code>git checkout -b KYLIN-4042</code></p>
</li>
<li><p>基于上述分支进行开发</p>
</li>
<li><p>将改动commit到本地，并push到远程</p>
</li>
<li><p>在github打开apache/kylin项目，页面会自动提示创建PR</p>
<p>  <img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-083731.jpg" alt="1562740942736"></p>
</li>
</ul>
<h5 id="正确地进行rebase"><a href="#正确地进行rebase" class="headerlink" title="正确地进行rebase"></a>正确地进行rebase</h5><p>Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。Rebase 的优势就是可以创造更线性的提交历史。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<p>如下图的项目，现在我们需要新建并切换到 bugFix 分支，进行提交一次，然后切换回 master 分支再提交一次。再次切换到 bugFix 分支，rebase  master 上的改动。</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-083244.png" alt="image-20190710145247466"></p>
<p>命令大致如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b BugFix</span><br><span class="line">git commit</span><br><span class="line">git checkout master</span><br><span class="line">git commit</span><br><span class="line">git checkout BugFix</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<h5 id="如何快速向上移动一个-多个commit"><a href="#如何快速向上移动一个-多个commit" class="headerlink" title="如何快速向上移动一个/多个commit"></a>如何快速向上移动一个/多个commit</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master^</span><br><span class="line">git checkout master~&#123;number&#125;</span><br></pre></td></tr></table></figure>
<h5 id="如何进行cherry-pick"><a href="#如何进行cherry-pick" class="headerlink" title="如何进行cherry-pick"></a>如何进行cherry-pick</h5><p>如下图的分支结构，现在需要将三个分支中的C3,C4,C7提交记录复制到 master 上</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-083223.png" alt="image-20190710163223053"></p>
<p><code>git cherry-pick C3 C4 C7</code></p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-10-084113.jpg" alt="1562748062533"></p>
<h5 id="使用rebase-i对commit进行合并与调整"><a href="#使用rebase-i对commit进行合并与调整" class="headerlink" title="使用rebase -i对commit进行合并与调整"></a>使用rebase -i对commit进行合并与调整</h5><p>如下图项目的commit记录</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-29-103344.png" alt="image-20190729183344260"></p>
<p>现在需要将最上面的两个commit合并为一个commit，这里就用到利器<code>rebase -i</code>命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i daee8c23fc740fc99a5be6a7fbc6dc8c78e3a46e</span><br></pre></td></tr></table></figure>
<p>出现如下编辑页面</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-29-105022.png" alt="image-20190729185021940"></p>
<p>将第二个commit修改为s(squash)，这个commit会被合并至前一个commit</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-29-105243.png" alt="image-20190729185243499"></p>
<p>出现如下编辑页面，修改commit message如下</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-29-105348.png" alt="image-20190729185347219"></p>
<p>再执行<code>git log</code>，最近的commit即变更为一个合并的commit</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-29-105458.png" alt="image-20190729185458540"></p>
<p>执行<code>git push -f</code>强行提交</p>
<h5 id="生成和合并patch"><a href="#生成和合并patch" class="headerlink" title="生成和合并patch"></a>生成和合并patch</h5><p>将最上面的2个commit生成为2个patch文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch HEAD^^</span><br></pre></td></tr></table></figure>
<p>执行patch文件的代码修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply 0001-This-is-commit-1-2.patch</span><br></pre></td></tr></table></figure>
<p>执行patch文件的代码修改并commit，并忽略空格</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am -3 <span class="comment">--ignore-whitespace 0001-This-is-commit-1-2.patch</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/Kylin-s-job-scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/Kylin-s-job-scheduler/" itemprop="url">Kylin的任务调度介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T15:24:04+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kylin的任务调度介绍"><a href="#Kylin的任务调度介绍" class="headerlink" title="Kylin的任务调度介绍"></a>Kylin的任务调度介绍</h1><p>Kylin的任务调度模式采用的是生产者-消费者模式。</p>
<p><img src="http://pqi7fpfop.bkt.clouddn.com/2019-04-30-090755.png" alt="image-20190430170743788"></p>
<p>Kylin的构建、合并、优化segment任务的入口为<code>EngineFactory</code>的<code>createBatchCubingJob</code>, <code>createBatchMergeJob</code>, <code>createBatchOptimizeJob</code>方法。<code>EngineFactory</code>是一个工厂类，可以根据不同的配置选择不同的cube构建类型（Batch或者Streaming）和不同的cube构建算法（Batch Cube有不同的构建算法）。</p>
<p>Kylin的可执行任务都被表示为一个<code>Executable</code>对象，基本的UML图如下</p>
<p><img src="http://pqi7fpfop.bkt.clouddn.com/2019-04-30-092920.png" alt="Executable"></p>
<p><code>Executable</code>的核心方法是<code>execute</code>，每个实现类可以定义Job的具体执行逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Job的具体执行逻辑</span></span><br><span class="line">    <span class="comment">//参数ExecutableContext Job的上下文</span></span><br><span class="line">    <span class="comment">//结果ExecuteResult Job的状态和输出</span></span><br><span class="line">    <span class="function">ExecuteResult <span class="title">execute</span><span class="params">(ExecutableContext executableContext)</span> <span class="keyword">throws</span> ExecuteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Job运行状态</span></span><br><span class="line">    <span class="function">ExecutableState <span class="title">getStatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Output <span class="title">getOutput</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunnable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获取Job的执行参数</span></span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">getParams</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象类<code>AbstractExecutable</code>实现了<code>Executable</code>接口，核心是实现了<code>execute</code>方法，为了清晰的定义每个Job的运行状态，AbstractExecutable将<code>execute</code>方法细化为<code>onExecuteStart</code>，<code>doWork</code>，<code>onExecuteError</code>，<code>onExecuteFinished</code>等阶段。其中execute方法修饰符为final，onExecuteStart，onExecuteError，onExecuteFinished方法修饰符为protected，doWork方法修饰符为protected abstract，用于子类根据自己的具体逻辑重写此方法。</p>
<p><code>execute</code>方法的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ExecuteResult <span class="title">execute</span><span class="params">(ExecutableContext executableContext)</span> <span class="keyword">throws</span> ExecuteException </span>&#123;</span><br><span class="line">        <span class="comment">//Job的状态从Ready 变为 Running</span></span><br><span class="line">        onExecuteStart(executableContext);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//不同的Job在这里实现具体逻辑</span></span><br><span class="line">        result = doWork(executableContext);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Job的状态从Ready 变为 Error</span></span><br><span class="line">            onExecuteError(exception, executableContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Job的状态从Ready 变为 Succeed or Error or Discard</span></span><br><span class="line">        onExecuteFinished(result, executableContext);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>AbstractExecutable的具体直接实现类主要<code>有ShellExecutable，HadoopShellExecutable，MapReduceExecutable，主要是根据自身的具体逻辑重写了</code>doWork`方法。</p>
<ul>
<li><code>ShellExecutable</code>主要用来执行Shell 命令可以直接执行的Job，像计算Hive表行数等Job。</li>
<li><code>HadoopShellExecutable</code>主要用来执行依赖Hadoop环境且用Shell执行的Job，像建字典，建立HBase表，Bulkload HFile等Job。</li>
<li><code>MapReduceExecutable</code>主要用来执行MapReduce类型的Job，像计算列基数，计算Cuboid， 生成HFile等Job。</li>
</ul>
<p>前面提到是<code>CubingJob</code>将构建cube的每一步job串了起来，其实<code>CubingJob</code>继承了<code>DefaultChainedExecutable</code>，DefaultChainedExecutable类继承了 AbstractExecutable类并实现了<code>ChainedExecutable</code>接口。CubingJob 主要是为Job关联了cube和segment的相关信息，串连所有Job的任务都是DefaultChainedExecutable类实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ChainedExecutable extends Executable &#123;</span><br><span class="line">    //获取所有子Job</span><br><span class="line">    List&lt;? extends AbstractExecutable&gt; getTasks();</span><br><span class="line">    //添加子Job</span><br><span class="line">    void addTask(AbstractExecutable executable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前提到在生成Job的时候，<code>CubingJob</code>通过<code>addTask</code>方法将所有子Job串连了起来。那么<code>DefaultChainedExecutable</code>到底是如何串连起所有子Job呢？关键在其重写的<code>doWork</code>方法里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ExecuteResult <span class="title">doWork</span><span class="params">(ExecutableContext context)</span> <span class="keyword">throws</span> ExecuteException </span>&#123;</span><br><span class="line">        List&lt;? extends Executable&gt; executables = getTasks();<span class="comment">//获取所有子Job</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; executables.size(); ++i) &#123;</span><br><span class="line">            Executable subTask = executables.get(i);</span><br><span class="line">            ExecutableState state = subTask.getStatus();</span><br><span class="line">            <span class="keyword">if</span> (state == ExecutableState.RUNNING) &#123;</span><br><span class="line">                <span class="comment">//子Job正在执行，等待它完成</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == ExecutableState.ERROR) &#123;</span><br><span class="line">               <span class="comment">//子Job执行失败，抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (subTask.isRunnable()) &#123;</span><br><span class="line">               <span class="comment">//每个Job在初始化后是Ready状态，所以isRunnable()是True，当子Job是Ready状态时，就开始执行。</span></span><br><span class="line">                <span class="keyword">return</span> subTask.execute(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecuteResult(ExecuteResult.State.SUCCEED, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>DefaultChainedExecutable</code> 也重写了<code>onExecuteFinished</code>方法，来根据所有子Job的状态更新整个Job的最终状态。</p>
<p>Kylin默认通过<code>DefaultScheduler</code>进行任务的调度，其核心逻辑是十分简单的，有两个线程池，一个线程池用来抓取所有Job的状态信息，一个线程池来执行具体的Job。基本的逻辑过程如下：</p>
<p><img src="http://pqi7fpfop.bkt.clouddn.com/2019-04-30-093909.png" alt="image-20190430173905136"></p>
<p>参考：<a href="https://blog.bcmeng.com/post/kylin-job.html" target="_blank" rel="noopener">https://blog.bcmeng.com/post/kylin-job.html</a></p>
<table>
<thead>
<tr>
<th>Category</th>
<th>KYLIN issue</th>
<th>Description</th>
<th>KAP issue</th>
<th>Status</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4107" target="_blank" rel="noopener">4107</a></td>
<td>Fix bug of StorageCleanupJob fails to delete Hive tables with “Argument list too long” error</td>
<td>P2</td>
<td></td>
<td>表名过长清理时报错，建议引入</td>
</tr>
<tr>
<td>Enhancement</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4117" target="_blank" rel="noopener">4117</a></td>
<td>Auto adjust data type of RelNode for intersect_count</td>
<td>P2</td>
<td></td>
<td>Rest客户端有可能抛出带有明文Klin密码的异常信息。需排查KE是否有此问题，若有，建议引入</td>
</tr>
<tr>
<td>Enhancement</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4137" target="_blank" rel="noopener">4137</a></td>
<td>Accelerate metadata reloading</td>
<td>P2</td>
<td></td>
<td>优化元数据重载，建议引入</td>
</tr>
<tr>
<td>Enhancement</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4101" target="_blank" rel="noopener">4101</a></td>
<td>Set hive and spark job name when building cube</td>
<td>P3</td>
<td></td>
<td>写起在yarn上的hive及spark任务的任务名，方便检查。无风险，建议引入</td>
</tr>
<tr>
<td>Enhancement</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4095" target="_blank" rel="noopener">4095</a></td>
<td>Add RESOURCE_PATH_PREFIX option in ResourceTool</td>
<td>P3</td>
<td></td>
<td>Resume人物后，任务输出没有清空，留的是上一次跑的输出结果，建议引入</td>
</tr>
<tr>
<td>Enhancement</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4092" target="_blank" rel="noopener">4092</a></td>
<td>Support setting seperate jvm params for kylin backgroud tools</td>
<td>P2</td>
<td></td>
<td>支持为使用kylin.sh跑的脚本工具配置jvm参数</td>
</tr>
<tr>
<td>Enhancement</td>
<td><a href="https://issues.apache.org/jira/browse/KYLIN-4091" target="_blank" rel="noopener">4091</a></td>
<td>Support fast mode and simple mode for running CI</td>
<td>P2</td>
<td></td>
<td>支持CI中cube的并发构建，来缩短CI时间，建议引入</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/Kylin-s-metadata-execute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chunen Ni">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞龙在天的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/Kylin-s-metadata-execute/" itemprop="url">Kylin的元数据-任务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T15:21:20+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/大数据/" itemprop="url" rel="index">
                    <span itemprop="name">大数据</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Kyin任务元数据基本介绍"><a href="#Kyin任务元数据基本介绍" class="headerlink" title="Kyin任务元数据基本介绍"></a>Kyin任务元数据基本介绍</h3><p>在<a href="https://nichunen.github.io/2019/03/30/Kylin-s-metadata-base/" title="Kylin的元数据基础" target="_blank" rel="noopener">Kylin的元数据基础</a>一文中介绍了kylin元数据的一些源码级基础知识。使用 Kylin生成每执行一个构建或合并任务，都会在Monitor页面生成一个job</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-09-093644.jpg" alt></p>
<p>Kylin使用存于resource store的metadata来实现元数据的持久化保存。</p>
<p>对于任务元数，Kylin使用了2中类型的元数据，分别为execute和execute_output</p>
<ul>
<li>execute：存储与表示任务的执行计划</li>
<li>execute_output：存储与表示任务的执行结果</li>
</ul>
<p>每个任务仅有一个execute元数据，会有(step_num + 1)个execute_output元数据，如下图所示为一dump下来的某个任务的元数据</p>
<p><img src="http://nichunen-pic.oss-cn-shanghai.aliyuncs.com/2019-07-09-093651.jpg" alt></p>
<p>execute的基本元数据类为<code>org.apache.kylin.job.dao.ExecutablePO</code>，代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutablePO</span> <span class="keyword">extends</span> <span class="title">RootPersistentEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务名</span></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 子任务列表</span></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"tasks"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;ExecutablePO&gt; tasks;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 任务类型</span></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"type"</span>)</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务参数</span></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"params"</span>)</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; params = Maps.newHashMap();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的json元数据文件示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"uuid"</span>: <span class="string">"99b80122-b59b-bbdb-5f22-26d1d9270220"</span>, </span><br><span class="line">    <span class="attr">"last_modified"</span>: <span class="number">1555246404591</span>, </span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.6.0.20500"</span>, </span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"BUILD CUBE - kylin_sales_cube - 20120101000000_20190430185000 - GMT+08:00 2019-04-14 20:53:24"</span>, </span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"uuid"</span>: <span class="string">"99b80122-b59b-bbdb-5f22-26d1d9270220-00"</span>, </span><br><span class="line">            <span class="attr">"last_modified"</span>: <span class="number">0</span>, </span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"2.6.0.20500"</span>, </span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Create Intermediate Flat Hive Table"</span>, </span><br><span class="line">            <span class="attr">"tasks"</span>: <span class="literal">null</span>, </span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"org.apache.kylin.source.hive.CreateFlatHiveTableStep"</span>, </span><br><span class="line">            <span class="attr">"params"</span>: &#123;</span><br><span class="line">                <span class="attr">"HiveInit"</span>: <span class="string">"USE default; "</span>, </span><br><span class="line">                <span class="attr">"HiveRedistributeData"</span>: <span class="string">"DROP TABLE IF EXISTS kylin_intermediate_kylin_sales_cube_86f98364_1485_001b_8fc5_18ec50930a14; CREATE EXTERNAL TABLE IF NOT EXISTS kylin_intermediate_kylin_sales_cube_86f98364_1485_001b_8fc5_18ec50930a14 ( KYLIN_SALES_TRANS_ID bigint ,KYLIN_SALES_PART_DT date ,KYLIN_SALES_LEAF_CATEG_ID bigint ,KYLIN_SALES_LSTG_SITE_ID int ,KYLIN_CATEGORY_GROUPINGS_META_CATEG_NAME string ,KYLIN_CATEGORY_GROUPINGS_CATEG_LVL2_NAME string ,KYLIN_CATEGORY_GROUPINGS_CATEG_LVL3_NAME string ,KYLIN_SALES_LSTG_FORMAT_NAME string ,KYLIN_SALES_SELLER_ID bigint ,KYLIN_SALES_BUYER_ID bigint ,BUYER_ACCOUNT_ACCOUNT_BUYER_LEVEL int ,SELLER_ACCOUNT_ACCOUNT_SELLER_LEVEL int ,BUYER_ACCOUNT_ACCOUNT_COUNTRY string ,SELLER_ACCOUNT_ACCOUNT_COUNTRY string ,BUYER_COUNTRY_NAME string ,SELLER_COUNTRY_NAME string ,KYLIN_SALES_OPS_USER_ID string ,KYLIN_SALES_OPS_REGION string ,KYLIN_SALES_PRICE decimal(19,4) ) STORED AS SEQUENCEFILE LOCATION 'hdfs://sandbox.hortonworks.com:8020/Users/nichunen/Downloads/template/kylin-99b80122-b59b-bbdb-5f22-26d1d9270220/kylin_intermediate_kylin_sales_cube_86f98364_1485_001b_8fc5_18ec50930a14'; ALTER TABLE kylin_intermediate_kylin_sales_cube_86f98364_1485_001b_8fc5_18ec50930a14 SET TBLPROPERTIES('auto.purge'='true'); INSERT OVERWRITE TABLE `kylin_intermediate_kylin_sales_cube_86f98364_1485_001b_8fc5_18ec50930a14` SELECT `KYLIN_SALES`.`TRANS_ID` as `KYLIN_SALES_TRANS_ID` ,`KYLIN_SALES`.`PART_DT` as `KYLIN_SALES_PART_DT` ,`KYLIN_SALES`.`LEAF_CATEG_ID` as `KYLIN_SALES_LEAF_CATEG_ID` ,`KYLIN_SALES`.`LSTG_SITE_ID` as `KYLIN_SALES_LSTG_SITE_ID` ,`KYLIN_CATEGORY_GROUPINGS`.`META_CATEG_NAME` as `KYLIN_CATEGORY_GROUPINGS_META_CATEG_NAME` ,`KYLIN_CATEGORY_GROUPINGS`.`CATEG_LVL2_NAME` as `KYLIN_CATEGORY_GROUPINGS_CATEG_LVL2_NAME` ,`KYLIN_CATEGORY_GROUPINGS`.`CATEG_LVL3_NAME` as `KYLIN_CATEGORY_GROUPINGS_CATEG_LVL3_NAME` ,`KYLIN_SALES`.`LSTG_FORMAT_NAME` as `KYLIN_SALES_LSTG_FORMAT_NAME` ,`KYLIN_SALES`.`SELLER_ID` as `KYLIN_SALES_SELLER_ID` ,`KYLIN_SALES`.`BUYER_ID` as `KYLIN_SALES_BUYER_ID` ,`BUYER_ACCOUNT`.`ACCOUNT_BUYER_LEVEL` as `BUYER_ACCOUNT_ACCOUNT_BUYER_LEVEL` ,`SELLER_ACCOUNT`.`ACCOUNT_SELLER_LEVEL` as `SELLER_ACCOUNT_ACCOUNT_SELLER_LEVEL` ,`BUYER_ACCOUNT`.`ACCOUNT_COUNTRY` as `BUYER_ACCOUNT_ACCOUNT_COUNTRY` ,`SELLER_ACCOUNT`.`ACCOUNT_COUNTRY` as `SELLER_ACCOUNT_ACCOUNT_COUNTRY` ,`BUYER_COUNTRY`.`NAME` as `BUYER_COUNTRY_NAME` ,`SELLER_COUNTRY`.`NAME` as `SELLER_COUNTRY_NAME` ,`KYLIN_SALES`.`OPS_USER_ID` as `KYLIN_SALES_OPS_USER_ID` ,`KYLIN_SALES`.`OPS_REGION` as `KYLIN_SALES_OPS_REGION` ,`KYLIN_SALES`.`PRICE` as `KYLIN_SALES_PRICE` FROM `DEFAULT`.`KYLIN_SALES` as `KYLIN_SALES` INNER JOIN `DEFAULT`.`KYLIN_CAL_DT` as `KYLIN_CAL_DT` ON `KYLIN_SALES`.`PART_DT` = `KYLIN_CAL_DT`.`CAL_DT` INNER JOIN `DEFAULT`.`KYLIN_CATEGORY_GROUPINGS` as `KYLIN_CATEGORY_GROUPINGS` ON `KYLIN_SALES`.`LEAF_CATEG_ID` = `KYLIN_CATEGORY_GROUPINGS`.`LEAF_CATEG_ID` AND `KYLIN_SALES`.`LSTG_SITE_ID` = `KYLIN_CATEGORY_GROUPINGS`.`SITE_ID` INNER JOIN `DEFAULT`.`KYLIN_ACCOUNT` as `BUYER_ACCOUNT` ON `KYLIN_SALES`.`BUYER_ID` = `BUYER_ACCOUNT`.`ACCOUNT_ID` INNER JOIN `DEFAULT`.`KYLIN_ACCOUNT` as `SELLER_ACCOUNT` ON `KYLIN_SALES`.`SELLER_ID` = `SELLER_ACCOUNT`.`ACCOUNT_ID` INNER JOIN `DEFAULT`.`KYLIN_COUNTRY` as `BUYER_COUNTRY` ON `BUYER_ACCOUNT`.`ACCOUNT_COUNTRY` = `BUYER_COUNTRY`.`COUNTRY` INNER JOIN `DEFAULT`.`KYLIN_COUNTRY` as `SELLER_COUNTRY` ON `SELLER_ACCOUNT`.`ACCOUNT_COUNTRY` = `SELLER_COUNTRY`.`COUNTRY` WHERE 1=1 AND (`KYLIN_SALES`.`PART_DT` &gt;= '2012-01-01' AND `KYLIN_SALES`.`PART_DT` &lt; '2019-04-30') ; "</span>, </span><br><span class="line">                <span class="attr">"cubeName"</span>: <span class="string">"kylin_sales_cube"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;, </span><br><span class="line">        &#123;&#125;</span><br><span class="line">    ], </span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"org.apache.kylin.engine.mr.CubingJob"</span>, </span><br><span class="line">    <span class="attr">"params"</span>: &#123;</span><br><span class="line">        <span class="attr">"submitter"</span>: <span class="string">"ADMIN"</span>, </span><br><span class="line">        <span class="attr">"envName"</span>: <span class="string">"DEV"</span>, </span><br><span class="line">        <span class="attr">"segmentId"</span>: <span class="string">"86f98364-1485-001b-8fc5-18ec50930a14"</span>, </span><br><span class="line">        <span class="attr">"notify_list"</span>: <span class="string">""</span>, </span><br><span class="line">        <span class="attr">"projectName"</span>: <span class="string">"learn_kylin"</span>, </span><br><span class="line">        <span class="attr">"jobType"</span>: <span class="string">"BUILD"</span>, </span><br><span class="line">        <span class="attr">"cubeName"</span>: <span class="string">"kylin_sales_cube"</span>, </span><br><span class="line">        <span class="attr">"segmentName"</span>: <span class="string">"20120101000000_20190430185000"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>execute_output的基本元数据类为<code>org.apache.kylin.job.dao.ExecutableOutputPO</code>，代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutableOutputPO</span> <span class="keyword">extends</span> <span class="title">RootPersistentEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"content"</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"status"</span>)</span><br><span class="line">    <span class="keyword">private</span> String status = <span class="string">"READY"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty</span>(<span class="string">"info"</span>)</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; info = Maps.newHashMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的全局任务json元数据文件示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"uuid"</span>: <span class="string">"99b80122-b59b-bbdb-5f22-26d1d9270220"</span>, </span><br><span class="line">    <span class="attr">"last_modified"</span>: <span class="number">1555246411812</span>, </span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.6.0.20500"</span>, </span><br><span class="line">    <span class="attr">"content"</span>: <span class="string">"org.apache.kylin.job.exception.ExecuteException: java.io.IOException: OS command error exit with return code: 127, error message: /bin/bash: hive: command not found</span></span><br><span class="line"><span class="string">The command is: </span></span><br><span class="line"><span class="string">hive -e \""</span>, </span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"ERROR"</span>, </span><br><span class="line">    <span class="attr">"info"</span>: &#123;</span><br><span class="line">        <span class="attr">"startTime"</span>: <span class="string">"1555246411762"</span>, </span><br><span class="line">        <span class="attr">"buildInstance"</span>: <span class="string">"62641@GggdeMacBook-Pro.local"</span>, </span><br><span class="line">        <span class="attr">"endTime"</span>: <span class="string">"1555246411811"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的子任务json元数据文件示例如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"uuid"</span>: <span class="string">"99b80122-b59b-bbdb-5f22-26d1d9270220-00"</span>, </span><br><span class="line">    <span class="attr">"last_modified"</span>: <span class="number">1555246411809</span>, </span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.6.0.20500"</span>, </span><br><span class="line">    <span class="attr">"content"</span>: <span class="string">"java.io.IOException: OS command error exit with return code: 127, error message: /bin/bash: hive: command not found</span></span><br><span class="line"><span class="string">The command is: </span></span><br><span class="line"><span class="string">hive -e \""</span>, </span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"ERROR"</span>, </span><br><span class="line">    <span class="attr">"info"</span>: &#123;</span><br><span class="line">        <span class="attr">"startTime"</span>: <span class="string">"1555246411769"</span>, </span><br><span class="line">        <span class="attr">"endTime"</span>: <span class="string">"1555246411807"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    <div>
          
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Chunen Ni</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            
            <div class="flagcounter">
              <a href="https://info.flagcounter.com/f9mZ"><img src="https://s01.flagcounter.com/count2/f9mZ/bg_F2F2F2/txt_000000/border_CCCCCC/columns_2/maxflags_12/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a>
            </div>
          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/nichunen" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:nic@apache.org" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chunen Ni</span>
  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
